    /*else if (flag_mode == GVS_AE_MODE)
    {
        for (int l = 0; l < 1; l++)
        {
            /// Import motion blurred frame ///
            Mat img_tot = imread("./test_ae/mb_noise_3.png", IMREAD_COLOR);

            /// Testing rotation ///
            Point2f center((img_tot.cols - 1) / 2.0, (img_tot.rows - 1) / 2.0);
            Mat rotation_matix = getRotationMatrix2D(center, 45, 1.0);
            warpAffine(img_tot, img_tot, rotation_matix, img_tot.size());
            int width = img_tot.cols - 500;
            int heigth = img_tot.rows - 400;
            cv::Rect crop_region((img_tot.cols / 2) - (width / 2), (img_tot.rows / 2) - (heigth / 2), width, heigth);
            img_tot = img_tot(crop_region);

            /// Go to gray scale ///
            cv::cvtColor(img_tot, img_tot, COLOR_RGBA2GRAY);

            /// Sobel filter ///
            // cv::Sobel(img_tot, img_tot, CV_8UC1, 1, 0);

            /// Find magnitude Mat ///
            Mat padded_img;
            int m = getOptimalDFTSize(img_tot.rows);
            int n = getOptimalDFTSize(img_tot.cols);

            copyMakeBorder(img_tot, padded_img, 0, m - img_tot.rows, 0, 0, BORDER_CONSTANT, Scalar::all(0));
            Mat planes[] = {Mat_<float>(padded_img), Mat::zeros(padded_img.size(), CV_32F)};
            Mat complexI;
            merge(planes, 2, complexI);
            dft(complexI, complexI);
            split(complexI, planes);
            magnitude(planes[0], planes[1], planes[0]); // planes[0] = magnitude
            Mat magI = planes[0];
            magI += Scalar::all(1); // switch to logarithmic scale
            log(magI, magI);
            // crop the spectrum, if it has an odd frame_idber of rows or columns
            magI = magI(Rect(0, 0, magI.cols & -2, magI.rows & -2));
            int cx = magI.cols / 2;
            int cy = magI.rows / 2;
            Mat q0(magI, Rect(0, 0, cx, cy));   // Top-Left - Create a ROI per quadrant
            Mat q1(magI, Rect(cx, 0, cx, cy));  // Top-Right
            Mat q2(magI, Rect(0, cy, cx, cy));  // Bottom-Left
            Mat q3(magI, Rect(cx, cy, cx, cy)); // Bottom-Right
            Mat tmp;                            // swap quadrants (Top-Left with Bottom-Right)
            q0.copyTo(tmp);
            q3.copyTo(q0);
            tmp.copyTo(q3);
            q1.copyTo(tmp); // swap quadrant (Top-Right with Bottom-Left)
            q2.copyTo(q1);
            tmp.copyTo(q2);
            normalize(magI, magI, 0, 1, NORM_MINMAX);

            /// LP filter on dft ///
            magI = ideal_low_pass_filter(magI, CUT_FREQ);

            /// Find maximum on of each col of magnitude Mat ///
            vector<Point> store; // Store the magnitude max point values
            int bound = int(magI.cols / 2);
            int llim = int(magI.cols / 2);
            int ulim = int(magI.cols / 2) + bound;
            int err = ERROR * magI.rows / 2;
            for (int k = llim; k < ulim; k++)
            {
                float max_col = 0.0f;
                int max_col_id = 0;
                for (int i = 0; i < magI.rows; i++)
                {
                    if (magI.at<float>(i, k) > max_col)
                    {
                        max_col = magI.at<float>(i, k);
                        max_col_id = i;
                    }
                }
                if (store.size() > 1)
                {
                    if (abs(max_col_id - store[store.size() - 1].y) <= err)
                    {
                        store.push_back(Point(k, max_col_id));
                    }
                }
                else
                {
                    store.push_back(Point(k, max_col_id));
                }
            }
            for (int i = 0; i < store.size(); i++)
            {
                circle(magI, Point(int(magI.cols / 2) + i, store[i].y), 1, Scalar(255, 255, 255), 1);
            }

            ofstream file_freq;
            file_freq.open("data_csv/data_1_rot.csv");
            vector<float> store_data;
            for (int i = 0; i < magI.rows; i++)
            {
                file_freq << magI.at<float>(i, magI.rows / 2) << "," << i << "\n";
                store_data.push_back(magI.at<float>(i, magI.rows / 2));
            }
            file_freq.close();

            int xc = int(magI.cols / 2);
            int yc = int(magI.rows / 2);
            int maxp = yc;
            int store_id = 0;

            int flag_app = MEAN_ANGLE;
            float mean_ang = 0.0f;
            float len = 0.0f;

            /// Linear interpoilation between points of store ///
            if (flag_app == LINEAR)
            {
                for (int i = 0; i < store.size(); i++)
                {
                    if (store[i].y >= maxp)
                    {
                        maxp = store[i].y;
                        store_id = i;
                    }
                }
                cv::cvtColor(magI, magI, COLOR_GRAY2RGBA);
                circle(magI, Point(store[store_id].x, store[store_id].y), 2, Scalar(0, 0, 255), 2);
                circle(magI, Point(xc + (xc - store[store_id].x), yc + (yc - store[store_id].y)), 2, Scalar(0, 0, 255), 2);
                line(magI, Point(store[store_id].x, store[store_id].y), Point(xc + (xc - store[store_id].x), yc + (yc - store[store_id].y)), Scalar(0, 0, 255), 1);
            }
            /// Mean of angles between center and each store point ///
            else if (flag_app == MEAN_ANGLE)
            {
                for (int k = 0; k < store.size(); k++)
                {
                    float angle = (atan2(xc - store[k].x, yc - store[k].y)) * (180 / CV_PI);
                    mean_ang += angle;
                }
                mean_ang /= store.size();
                mean_ang += 90;
                mean_ang = 45;

                double s = sin(mean_ang * CV_PI / 180);
                double c = cos(mean_ang * CV_PI / 180);
                Point p0(xc + c * 250, yc - s * 250);
                Point p1(xc - c * 250, yc + s * 250);

                cv::cvtColor(magI, magI, COLOR_GRAY2RGBA);
                circle(magI, p0, 2, Scalar(0, 0, 255), 2);
                circle(magI, p1, 2, Scalar(0, 0, 255), 2);
                line(magI, Point(xc, yc), p0, Scalar(0, 0, 255), 1);
                line(magI, Point(xc, yc), p1, Scalar(0, 0, 255), 1);

                line(padded_img, Point(xc, yc), p0, Scalar(255, 255, 255), 1);
                line(padded_img, Point(xc, yc), p1, Scalar(255, 255, 255), 1);
            }
            else if (flag_app == 10)
            {
            }
            ///////////////////////////////////////////////////
            int id_r = int(store_data.size() / 2) + 5;
            int min_id_r = 0;
            while (store_data[id_r] >= store_data[id_r + 1])
            {
                min_id_r = id_r;
                id_r++;
            }
            int id_l = int(store_data.size() / 2) - 5;
            int min_id_l = 0;
            float ff = 0.0f;
            while (store_data[id_l] >= store_data[id_r - 1])
            {
                min_id_l = id_l;
                id_l--;
                ff = store_data[id_l - 1];
            }
            float magnitude = min_id_r - min_id_l;
            ////////////////////////////////////////////
            float s1 = sin((mean_ang + 90) * CV_PI / 180);
            float c1 = cos((mean_ang + 90) * CV_PI / 180);

            Point pc = Point(magI.cols / 2, (magI.rows / 2));
            Point p4(pc.x + c1 * magnitude, pc.y - s1 * magnitude);

            circle(magI, Point(magI.cols / 2, (magI.rows / 2)), 2, Scalar(255, 0, 0), 2);
            arrowedLine(magI, pc, p4, Scalar(255, 0, 0), 2);

            circle(padded_img, Point(padded_img.cols / 2, (padded_img.rows / 2)), 2, Scalar(255, 0, 0), 2);
            arrowedLine(padded_img, pc, p4, Scalar(255, 255, 255), 2);

            cout << "Mean_angle: " << mean_ang << endl;
            cout << "Magnitude: " << magnitude << endl;

            show_img(padded_img, "Padded space domain");
            show_img(magI, "Frequency domain");
            waitKey(0);
        }
    }*/